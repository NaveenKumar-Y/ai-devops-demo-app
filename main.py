from fastapi import FastAPI, Request
from github import Github, GithubException
import requests
import os
import json

app = FastAPI()

# Configuration
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
# Using a slightly lower temperature for more deterministic code generation
# OLLAMA_URL = "http://localhost:11434/api/generate"
OLLAMA_URL = "http://naveen-aicontrolplane.eastus.cloudapp.azure.com:11434/api/generate"  #replace endpoint with your server IP/hostname
# MODEL_NAME = "llama3" 
# MODEL_NAME = "qwen2.5:0.5b" 
MODEL_NAME = "gemma2:2b" 
# MODEL_NAME = "llama3.2:1b" 

g = Github(GITHUB_TOKEN)

@app.get("/")
def home():
    return {"status": "AI DevOps Agent Running"}

# --- AI CORE FUNCTIONS ---

def generate_text(prompt):
    """Generic wrapper for Ollama generation"""
    try:
        response = requests.post(
            OLLAMA_URL,
            json={
                "model": MODEL_NAME,
                "prompt": prompt,
                "stream": False,
                "options": {"temperature": 0.2} # Low temp keeps code accurate
            },
            timeout=180
        )
        if response.status_code != 200:
            print(f"Ollama Error: {response.text}")
            return "# Error generating content"
        
        data = response.json()


        return data.get("response", "")
    except Exception as e:
        print(f"Generation failed: {str(e)}")
        return "# Error generating content"

def detect_tech_stack(description):
    """
    Agentic Decision: Analyzes the description to pick a tech stack.
    """
    if not description:
        print("No description found, defaulting to Python.")
        return "python" 
    
    print(f"Analyzing description: {description}")
    
    prompt = f"""
    Analyze this repository description: "{description}"
    Identify the primary programming language or framework intended.
    Return ONLY one word from this list: [python, nodejs, go, java, react, unknown].
    If unsure, return 'python'.
    Do not add punctuation or explanation.
    """
    
    tech_stack = generate_text(prompt).strip().lower()
    # Clean up response in case model adds extra text
    tech_stack = tech_stack.split()[0].replace(".", "")
    print(f"AI Detected Stack: {tech_stack}")
    return tech_stack

def generate_dockerfile(tech_stack):
    print(f"Generating Dockerfile for {tech_stack}...")
    prompt = f"""
    Create a production-ready Dockerfile for a {tech_stack} application.
    Requirements:
    - Use a slim or alpine base image.
    - Follow best practices for {tech_stack}.
    - Add a comment at the top: "# Generated by AI Agent for {tech_stack}".
    - OUTPUT ONLY THE CODE starting with "FROM". NO MARKDOWN. NO EXPLANATION. NO punctuation. NO backticks . Start the output immediately with the first line of the code.
    """
    return generate_text(prompt)

def generate_ci(tech_stack):
    print(f"Generating CI/CD for {tech_stack}...")
    prompt = f"""
    Create a GitHub Actions workflow (.github/workflows/ci.yml) for a {tech_stack} app.
    Steps:
    trigger on push to main
    1. Checkout code
    2. Set up {tech_stack} environment
    3. Install dependencies
    4. Build Docker image
    
    - Add a comment at the top: "# Generated by AI Agent for {tech_stack}".
    - OUTPUT ONLY THE YAML CODE starting with "name:". NO MARKDOWN. NO EXPLANATION. NO punctuation. NO backticks . Start the output immediately with the first line of the code.
    - Do not include any backticks ``` in entire workflow yaml
    """

    return generate_text(prompt)

def generate_readme(repo_name, description, tech_stack):
    prompt = f"""
    Create a generic README.md for a repository named {repo_name}.
    Description provided: {description}
    Tech Stack: {tech_stack}
    Include sections for: Introduction, Setup, and Docker Instructions.
    OUTPUT ONLY THE MARKDOWN CONTENT.
    """
    return generate_text(prompt)

# --- GITHUB AUTOMATION ---

def push_file_safely(repo, branch, path, content, message):
    """Helper to create or update a file without crashing"""
    try:
        # Check if file exists to get SHA for update
        contents = repo.get_contents(path, ref=branch)
        repo.update_file(contents.path, message, content, contents.sha, branch=branch)
        print(f"Updated {path}")
    except GithubException:
        # File doesn't exist, create it
        try:
            repo.create_file(path, message, content, branch=branch)
            print(f"Created {path}")
        except GithubException as e:
            print(f"Failed to create {path}: {e}")

def create_pr(repo_name, description):
    print(f"Starting agent workflow for: {repo_name}")
    
    # 1. Connect to Repo
    try:
        repo = g.get_repo(repo_name)
    except GithubException:
        print(f"Repo {repo_name} not found or accessible.")
        return

    # 2. Determine Tech Stack (The "Agentic" part)
    tech_stack = detect_tech_stack(description)
    
    # 3. Setup Branch Logic
    branch_name = "ai-bootstrap"
    base_branch = "main" # Default github branch
    
    try:
        # Check if main exists (it might not if repo is purely empty)
        source = repo.get_branch(base_branch)
        sha = source.commit.sha
    except GithubException:
        print("Repo is empty (no main branch). Creating initial commit directly.")
        # If empty, we can't create a branch off nothing. 
        # Strategy: Create README directly to initialize 'main'
        readme_content = generate_readme(repo_name, description, tech_stack)
        repo.create_file("README.md", "Initial commit by AI", readme_content)
        
        # Now main exists, refresh ref
        source = repo.get_branch(base_branch)
        sha = source.commit.sha

    # Create feature branch
    try:
        repo.get_branch(branch_name)
        print(f"Branch {branch_name} already exists.")
    except GithubException:
        repo.create_git_ref(ref=f"refs/heads/{branch_name}", sha=sha)
        print(f"Created branch {branch_name}.")

    # 4. Generate & Push Files
    dockerfile_content = generate_dockerfile(tech_stack)
    ci_content = generate_ci(tech_stack)

    # print(dockerfile_content)
    # print("---"*10)    
    # print(ci_content)
    push_file_safely(repo, branch_name, "Dockerfile", dockerfile_content, "Add Dockerfile")
    push_file_safely(repo, branch_name, ".github/workflows/ci.yml", ci_content, "Add CI Pipeline")

    # 5. Create PR
    try:
        # Check if PR already exists to avoid duplicates
        pulls = repo.get_pulls(state='open', head=f"{repo.owner.login}:{branch_name}")
        if pulls.totalCount == 0:
            repo.create_pull(
                title=f"AI Setup: {tech_stack.capitalize()} Boilerplate [skip ci]",
                body=f"Detected intent: **{tech_stack}** based on description.\n\nAutomated setup includes:\n- Dockerfile\n- CI/CD Pipeline",
                head=branch_name,
                base=base_branch
            )
            print(f"PR Created for {repo_name}")
        else:
            print("PR already exists.")
    except GithubException as e:
        print(f"PR Creation failed: {e}")




def review_pull_request(repo_name, pr_number):
    print(f"Reviewing PR #{pr_number} in {repo_name}...")
    
    repo = g.get_repo(repo_name)
    pr = repo.get_pull(pr_number)
    
    # 1. Get the Code Changes (Diff)
    #  grab the changed files.
    files = pr.get_files()
    diff_text = ""
    
    for file in files:
        # Skip auto-generated or lock files to save tokens
        if file.filename.endswith("lock.json") or file.filename.endswith(".png"):
            continue
            
        # Get the patch (the actual +/- changes)
        diff_text += f"\n--- File: {file.filename} ---\n"
        diff_text += file.patch if file.patch else "Binary file or large change."

    if not diff_text:
        print("No reviewable changes found.")
        return

    # 2. Ask the AI to Review
    prompt = f"""
    You are a Senior Code Reviewer. Review the following git diff.
    Focus on:
    1. Security vulnerabilities (leaked secrets, injection attacks).
    2. Potential bugs (logic errors).
    3. Code quality (clean code principles).
    
    Be concise. If the code looks good, just say "LGTM".
    
    DIFF:
    {diff_text[:4000]}  # Truncate to avoid hitting token limits
    """
    
    review_comment = generate_text(prompt)
    
    # 3. Post the Review as a Comment
    try:
        pr.create_issue_comment(f"##  AI Code Review\n\n{review_comment}")
        print(f" Review posted on PR #{pr_number}")
    except GithubException as e:
        print(f" Failed to post comment: {e}")



# --- WEBHOOK HANDLER ---

@app.post("/webhook")
async def webhook(request: Request):
    payload = await request.json()
    
    # Filter for Repository Creation Event
    # We check if 'repository' key exists to avoid crashing on ping events
    if payload.get("action") == "created" and "repository" in payload:
        repo_data = payload["repository"]
        repo_name = repo_data["full_name"]
        description = repo_data.get("description", "") # Get description safely
        
        print(f"New repo detected: {repo_name}")
        print(f"Description: {description}")
        
        # Trigger the Agent
        create_pr(repo_name, description)
    
    if payload.get("action")  in ["opened", "synchronize"] and "pull_request" in payload:
        repo_name = payload["repository"]["full_name"]
        pr_number = payload["pull_request"]["number"]
    
    # Skip our own AI-created PRs to avoid infinite loops!
    # We check if the PR branch is 'ai-bootstrap'
    if "pull_request" in payload:
        if payload["pull_request"]["head"]["ref"] == "ai-bootstrap":
            print("Skipping review of AI-generated PR.")
        else:
            review_pull_request(repo_name, pr_number)
        
    return {"status": "ok"}

